#
# Special case for matrix vector product
# where the matrix has only two non-zero diagonals:
# the main diagonal dm, and a diagonal dl located below dm
# multiplied with a vector of the same length as dm
#
# e.g.
# | 1 0 0 0 0 |   | 5 |   |  5 |
# | 0 2 0 0 0 |   | 5 |   | 10 |
# | 1 0 3 0 0 | * | 5 | = | 20 | 
# | 0 2 0 4 0 |   | 5 |   | 30 |
# | 0 0 3 0 5 |   | 5 |   | 40 |
#

let take = \v.\a.
    with (0 * v) <= iv < v do
        a.(iv)
in

let create = \s.\x.
    with 0 <= iv < s do
        x
in

let matmul = \dm.\dl.\v.
    let maind = dm * v in
    let lowerd = dl * take (shape dl) v in
    let zeros = create ((shape dm) - (shape dl)) 0 in
    maind + (zeros @ lowerd)
in

let dm = [1,2,3,4,5] in
let dl = [1,2,3] in
let v = [5, 5, 5, 5, 5] in

let res_f = matmul dm dl v in
let res_s = shape (matmul dm dl v) in
let res_d = dim (matmul dm dl v) in

[res_f, res_s, res_d]

#
# Rewrites to:
#
# let take_f = \v.\a. with [0 * v] <= iv < [v] do a.(iv) in
# let take_s = \v.\a. (v - []) @ [] in
# let take_d = \v.\a. 0 + 0 in
# 
# let create_f = \s.\x. with [0] <= iv < [s] do x in
# let create_s = \s.\x. (s - []) @ x in
# let create_d = \s.\x. 0 + x in
# 
# let matmul_f = \dm.\dl.\v.
#     let maind = dm * v in
#     let lowerd = dl * (take_f (shape dl) v) in
#     let zeros = create_f ((shape dm) - (shape dl)) 0 in
#     maind + (zeros @ lowerd)
# in
# 
# let matmul_s = \dm.\dl.\v.
#     let maind = dm in
#     let lowerd = dl in
#     let zeros = create_s [(shape dm).(0)] [] in
#     maind
# in
# 
# let matmul_d = \dm.\dl.\v.
#     let maind = dm in
#     let lowerd = dl in
#     let zeros = create_d 1 0 in
#     maind
# in
# 
# let dm = [1, 2, 3, 4, 5] in
# let dl = [1, 2, 3] in
# let v = [5, 5, 5, 5, 5] in
# 
# let res_f = matmul_f dm dl v in
# let res_s = matmul_s (shape dm) (shape dl) (shape v) in
# let res_d = matmul_d (dim dm) (dim dl) (dim v) in
# 
# [res_f, res_s, res_d]
#
